<#@ template debug="true" hostspecific="true" language="C#" #>
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml"#>
<#@ assembly name="System.Xml.Linq"#>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ output extension=".cs" #>
<# 
	XmlSchemaSet schemaSet = new XmlSchemaSet();
	//schemaSet.
 //XmlSchemaSet.Read(new FileStream(structuresPath, FileMode.Open), null);
	String structuresPath = this.Host.ResolvePath("Structures.xsd");
	XmlSchema primarySchema = XmlSchema.Read(new FileStream(structuresPath, FileMode.Open), null);
	schemaSet.Add(primarySchema);
	String[] additionalSchemaFiles = {
		"ExternalTypes.xsd",
		"MissingTypes.xsd"
	};
	foreach (var filename in additionalSchemaFiles){
		schemaSet.Add(XmlSchema.Read(new FileStream(this.Host.ResolvePath(filename), FileMode.Open), null));
	}
	schemaSet.Compile();
	if (!schemaSet.IsCompiled || !primarySchema.IsCompiled){
		throw new InvalidOperationException("Schema failed to compile");
	}
	var schemaItems = primarySchema.Items;

	Dictionary<String, ClassDef> classes = new Dictionary<String, ClassDef>();
	foreach	(XmlSchemaObject item in schemaItems){
		XmlSchemaComplexType typeDef = item as XmlSchemaComplexType;
		if (typeDef == null){
			String message = "Handling of type not implemnted: " + item;
			this.Host.LogErrors(new CompilerErrorCollection(){
				new CompilerError(structuresPath, item.LineNumber, item.LinePosition, "Unknown type", message)
			});
			continue;
		}
		XmlSchemaType baseType = typeDef.BaseXmlSchemaType;
		WriteLine("//Processing {0}...", typeDef.Name);
		bool isDataItem = baseType.Name == "BaseDataItem";
		ClassDef def = new ClassDef();
		def.definition = typeDef;
		def.isDataItem = isDataItem;
		def.name = typeDef.Name;
		classes[def.name] = def;
	}
	WriteLine("//Found {0} items", classes.Count);
	//parse things further since we now know all classes in the template file
	foreach (var def in classes.Values){
		WriteLine("//defining {0}...", def.name);
		XmlSchemaComplexType typeDef = def.definition;
		XmlSchemaSequence sequence = (XmlSchemaSequence)def.definition.ContentTypeParticle;
		def.fields = new List<FieldDef>(sequence.Items.Count + typeDef.Attributes.Count);
		WriteLine("//{0} has {1} attributes", def.name, typeDef.Attributes.Count);
		foreach (XmlSchemaAttribute attr in typeDef.Attributes)
		{
			FieldDef field = new FieldDef();
			field.name = attr.Name;
			field.isAttribute = true;
			field.typeName = attr.SchemaTypeName.Name;
			if (attr.Annotation != null)
			{
				XmlSchemaDocumentation documentation = attr.Annotation.Items.OfType<XmlSchemaDocumentation>().FirstOrDefault();
				if (documentation != null){
					XmlNode node = documentation.Markup.FirstOrDefault();
					if (node != null){
						field.documentation = node.InnerText;
						//WriteLine(field.documentation);
					}
				}
			}
			def.fields.Add(field);
		}
		
		foreach	(XmlSchemaElement item in sequence.Items){
			if (item.Name == "DataId"){
				//skip that one. It will be present in the base class
				continue;
			}
			FieldDef field = new FieldDef();
			field.name = item.Name;
			//item.
			if (item.Annotation != null)
			{
				XmlSchemaDocumentation documentation = item.Annotation.Items.OfType<XmlSchemaDocumentation>().FirstOrDefault();
				if (documentation != null){
					XmlNode node = documentation.Markup.FirstOrDefault();
					if (node != null){
						field.documentation = node.InnerText;
						//WriteLine(field.documentation);
					}
				}
			}

			if (item.UnhandledAttributes != null)
			{
				foreach (XmlAttribute unhandled in item.UnhandledAttributes)
				{
					switch (unhandled.LocalName){
						case "isDbLazy":
							field.isDbLazy = XmlConvert.ToBoolean(unhandled.Value);
							break;
						case "isDict":
							field.isDict = XmlConvert.ToBoolean(unhandled.Value);
							break;
						case "keyType":
							field.keyType = unhandled.Value;
							break;
						case "valueType":
							field.valueType = unhandled.Value;
							break;
						case "listItemType":
							field.listType = unhandled.Value;
							field.isList = true;
							break;
						default:
							this.Host.LogErrors(new CompilerErrorCollection(){
								new CompilerError(structuresPath, item.LineNumber, item.LinePosition,
								"Unknown attribute", String.Format("Attribute '{0}' is unknown", unhandled.LocalName))
								});
							break;
					}
				}
			}
			if (item.SchemaType != null)
			{
				//that is a list
				field.isList = true;
			}
			field.type = item.SchemaTypeName.Name;
			field.nullable = item.IsNillable;
			WriteLine("//Item {0} is of type {1}{2}", field.name, item.SchemaTypeName, field.isDbLazy ? "DbLazy" : "");
			def.fields.Add(field);
		}
	}
	String foo= "";

#>


<#+
	class ClassDef{
		public bool isDataItem;
		public String name;
		public XmlSchemaComplexType definition;
		public List<FieldDef> fields;
	}
	class FieldDef{
		public bool isAttribute;
		public String documentation;
		public string name;
		public String type;
		public String typeName;
		public bool referById = false;
		public bool isDbLazy;
		public bool isDict;
		public bool isList;
		public String keyType, valueType;
		public String listType;
		public bool nullable;
	}

 #>