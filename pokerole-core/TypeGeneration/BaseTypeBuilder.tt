/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
<#@ include file="BaseTypeBuilder.ttinclude"#>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml"#>
<#@ assembly name="System.Xml.Linq"#>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Schema" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.CodeDom.Compiler" #>
<#@ output extension=".cs" #>
<# 
	XmlSchemaSet schemaSet = new XmlSchemaSet();
	String structuresPath = this.Host.ResolvePath("Structures.xsd");
	XmlSchema primarySchema = XmlSchema.Read(new FileStream(structuresPath, FileMode.Open), null);
	schemaSet.Add(primarySchema);
	String[] additionalSchemaFiles = {
		"ExternalTypes.xsd",
		"MissingTypes.xsd"
	};
	foreach (var filename in additionalSchemaFiles){
		schemaSet.Add(XmlSchema.Read(new FileStream(this.Host.ResolvePath(filename), FileMode.Open), null));
	}
	schemaSet.Compile();
	if (!schemaSet.IsCompiled || !primarySchema.IsCompiled){
		throw new InvalidOperationException("Schema failed to compile");
	}
	var schemaItems = primarySchema.Items;

	Dictionary<String, ClassDef> classes = new Dictionary<String, ClassDef>();
	foreach	(XmlSchemaObject item in schemaItems){
		XmlSchemaComplexType typeDef = item as XmlSchemaComplexType;
		if (typeDef == null){
			XmlSchemaElement element= item as XmlSchemaElement;
			if (element != null && element.Name == "PokeroleData")
			{
				//skip that one
				continue;
			}
			String message = "Handling of type not implemnted: " + item;
			this.Host.LogErrors(new CompilerErrorCollection(){
				new CompilerError(structuresPath, item.LineNumber, item.LinePosition, "Unknown type", message)
			});
			continue;
		}
		XmlSchemaType baseType = typeDef.BaseXmlSchemaType;
		bool isDataItem = baseType.Name == "BaseDataItem";
		ClassDef def = new ClassDef();
		def.definition = typeDef;
		def.isDataItem = isDataItem;
		def.name = typeDef.Name;
		classes[def.name] = def;
	}
	//parse things further since we now know all classes in the template file
	foreach (var def in classes.Values){
		XmlSchemaComplexType typeDef = def.definition;
		XmlSchemaSequence sequence = (XmlSchemaSequence)def.definition.ContentTypeParticle;
		def.fields = new List<FieldDef>(sequence.Items.Count + typeDef.Attributes.Count);
		foreach (XmlSchemaAttribute attr in typeDef.Attributes)
		{
			FieldDef field = new FieldDef();
			field.name = attr.Name;
			field.isAttribute = true;
			field.type = NormalizeType(attr.SchemaTypeName.Name);
			if (attr.Annotation != null)
			{
				XmlSchemaDocumentation documentation = attr.Annotation.Items.OfType<XmlSchemaDocumentation>().FirstOrDefault();
				if (documentation != null){
					XmlNode node = documentation.Markup.FirstOrDefault();
					if (node != null){
						field.documentation = node.InnerText;
					}
				}
			}
			def.fields.Add(field);
		}
		
		foreach	(XmlSchemaElement item in sequence.Items){
			if (item.Name == "DataId"){
				//skip that one. It will be present in the base class
				continue;
			}
			FieldDef field = new FieldDef();
			field.name = item.Name;
			if (item.Annotation != null)
			{
				XmlSchemaDocumentation documentation = item.Annotation.Items.OfType<XmlSchemaDocumentation>().FirstOrDefault();
				if (documentation != null){
					XmlNode node = documentation.Markup.FirstOrDefault();
					if (node != null){
						field.documentation = node.InnerText;
					}
				}
			}

			if (item.UnhandledAttributes != null)
			{
				foreach (XmlAttribute unhandled in item.UnhandledAttributes)
				{
					String type;
					switch (unhandled.LocalName){
						case "isDbLazy":
							field.isDbLazy = XmlConvert.ToBoolean(unhandled.Value);
							break;
						case "isDict":
							field.isDict = XmlConvert.ToBoolean(unhandled.Value);
							break;
						case "keyType":
							type = GrabTypeFromAttribute(item, unhandled, structuresPath);
							if (type == null){
								continue;
							}
							field.keyType = type;
							break;
						case "valueType":
							type = GrabTypeFromAttribute(item, unhandled, structuresPath);
							if (type == null){
								continue;
							}
							field.valueType = type;
							break;
						case "listItemType":
							type = GrabTypeFromAttribute(item, unhandled, structuresPath);
							if (type == null){
								continue;
							}
							field.listType = type;
							field.isList = true;
							break;
						case "genericType":
							type = GrabTypeFromAttribute(item, unhandled, structuresPath);
							if (type == null){
								continue;
							}
							field.genericType = type;
							break;
						default:
							this.Host.LogErrors(new CompilerErrorCollection(){
								new CompilerError(structuresPath, item.LineNumber, item.LinePosition,
								"Unknown attribute", String.Format("Attribute '{0}' is unknown", unhandled.LocalName))
								});
							break;
					}
				}
			}
			field.type = NormalizeType(item.SchemaTypeName.Name);
			field.isReferenceType = IsReferenceType(schemaSet, item.SchemaTypeName) || field.isList || field.isDict;
			//ClassDef other;
			//if (classes.TryGetValue(field.type, out other) && other.isDataItem){
				//field.type = String.Format("ItemReference<{0}>", field.type);
			//}
			field.nullable = item.IsNillable;
			def.fields.Add(field);
		}
	}
 #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Collections.ObjectModel;
using System.Xml.Serialization;
using System.Xml;
using System.Diagnostics;
using System.ComponentModel;

namespace Pokerole.Core{
<#
	//make the classes!!!
	foreach	(ClassDef classDef in classes.Values)
	{
		StringBuilder constructorArgBuilder = new StringBuilder(classDef.fields.Count * 20);
		if (classDef.isDataItem)
		{
#>	[System.CodeDom.Compiler.GeneratedCode("BaseTypeBuilder.tt", "??")]
	public partial record <#=classDef.name#> : BaseDataItem
	{
<#
		}
		else{
#>	[System.CodeDom.Compiler.GeneratedCode("BaseTypeBuilder.tt", "??")]
	public record <#=classDef.name#>
	{
<#
		}
		Write("\t\tpublic {0}(", classDef.name);
		bool firstParam = true;
		if (classDef.isDataItem){
			firstParam = false;
			Write("DataId dataId");
		}
		foreach	(FieldDef field in classDef.fields){
			if (firstParam){
				firstParam = false;
			}
			else{
				Write(",\r\n\t\t\t");
			}
			Write("{0} {1}", field.GetTypeDeclaration(false, false), LowercaseInitial(field.name));
		}
		Write(")");
		if (classDef.isDataItem){
			Write(" : base(dataId)");
		}
#>

		{
<#
		foreach(FieldDef field in classDef.fields){
			Write("\t\t\t{0} = {1};\r\n", field.name, field.GetAssignment(LowercaseInitial(field.name), true));
		}
#>
		}
<#
		foreach(FieldDef field in classDef.fields){
#>
		/// <summary>
		/// <#= !String.IsNullOrEmpty(field.documentation) ? field.documentation : "Someone didn't document this item..." #>
		/// </summary>
		public <#= field.GetTypeDeclaration(true, false) #> <#=field.name#> { get; }
<#		}
		//if (!classDef.isDataItem)
		//{
			////finish off the class since the other terminator won't get hit due to continue
			//Write("\t}\r\n");
			//continue;
		//}
		String lowercaseClassName = LowercaseInitial(classDef.name);
#>
		public class Builder : <#= String.Format(classDef.isDataItem ? "DataItemBuilder<{0}>" : "ItemBuilder<{0}>",
 classDef.name)#>
		{
			public Builder() { }
			public Builder(<#=classDef.name#> <#=lowercaseClassName#>)
			{
<#
		if (classDef.isDataItem)
		{
#>
				DataId = <#=lowercaseClassName#>.DataId;
<#
		}
#>
<#
		foreach (FieldDef field in classDef.fields){
			String assignment = field.GetAssignment(String.Format("{0}.{1}", lowercaseClassName, field.name), false);
			Write("\t\t\t\t{0} = {1};\r\n", field.name, assignment);
		}
#>
			}
<#
  #if false
		if (classDef.isDataItem)
		{
#>
			[XmlElement(IsNullable = false)]
			DataId? DataId {get; set;}
<#
		}
  #endif
		foreach	(FieldDef field in classDef.fields)
		{
			bool needsBuilderEntry = false;
			ClassDef otherDef = null;
			if (field.isList && classes.TryGetValue(field.listType, out otherDef))
			{
				needsBuilderEntry = true;
			}

#>
			/// <summary>
			/// <#= !String.IsNullOrEmpty(field.documentation) ? field.documentation : "Someone didn't document this item..." #>
			/// </summary>
			[<#
			if (field.isAttribute)
			{
				Write("XmlAttribute()");
			}
			else if (needsBuilderEntry)
			{
				Write("XmlIgnore");
			}
			else
			{
				Write("XmlElement(IsNullable = {0})", field.nullable ? "true" : "false");
			}
#>]
			public <#= field.GetTypeDeclaration(false, true) #> <#=field.name#> { get; set; }
<#			if (needsBuilderEntry)
			{#>
			[Browsable(false)]
			[DebuggerHidden]
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			[XmlArray("<#=field.name#>", IsNullable = <#=field.nullable ? "true" : "false"#>)]
			[XmlArrayItem("<#=otherDef.name#>")]
			public <#=otherDef.name#>.Builder[] <#=field.name#>Builder
			{
				get
				{
					if (<#=field.name#> == null)
					{
						return Array.Empty<<#=otherDef.name#>.Builder>();
					}
					return <#=field.name#>.Select(item=>new <#=otherDef.name#>.Builder(item)).ToArray();
				}
				set
				{
					<#=field.name#>?.Clear();
					if (value == null)
					{
						return;
					}
					if (<#=field.name#> == null)
					{
						<#=field.name#> = new List<<#=otherDef.name#>>(value.Length);
					}
					ItemBuilder<<#=otherDef.name#>>.BuildList(value, <#=field.name#>);
				}
			}
<#			}
		}#>
			/// <summary>
			/// Whether or not all of the required Properites of this instance are set to build a new
			/// <see cref="<#=classDef.name#>"/>. <see cref="Build"/> will throw an exception if this returns false.
			/// </summary>
			public override bool IsValid
			{
				get
				{
<#		if (classDef.isDataItem)
		{#>
					if (DataId is null)
					{
						return false;
					}
<#		}#>
<#
		foreach(FieldDef field in classDef.fields)
		{
			if (field.nullable)
			{
				//no check needed
				continue;
			}#>
					if (<#=field.name#> is null)
					{
						return false;
					}
<#
		}
#>
					return true;
				}
			}
			/// <summary>
			/// Build and instance of <see cref="<#=classDef.name#>"/> from this Builder
			/// </summary>
			/// <returns>A new instance of <see cref="<#=classDef.name#>"/></returns>
			/// <exception cref="InvalidOperationException">If this method is called when not all required properties
			/// have been set</exception>
			public override <#=classDef.name#> Build(){
				if (!IsValid)
				{
					throw new InvalidOperationException("Not all required fields were set");
				}
				return new <#=classDef.name#>(<#
		firstParam = true;
		if (classDef.isDataItem)
		{
			firstParam = false;
			Write("DataId!.Value");
		}
		foreach (FieldDef field in classDef.fields)
		{
			if (firstParam)
			{
				firstParam = false;
			}
			else
			{
				Write(",");
			}
			Write("\r\n\t\t\t\t\t");
			if (field.nullable)
			{
				Write(field.name);
				continue;
			}
			if (!field.isReferenceType)
			{
				Write("{0}!.Value", field.name);
				continue;
			}
			Write("{0}!", field.name);
		}
  #>);
			}
		}
	}
<#}

#>
}